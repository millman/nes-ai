{% extends "base.html" %}

{% block extra_head %}
<link rel="stylesheet" href="{{ url_for('static', filename='common_styles.css') }}">
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<script src="{{ url_for('static', filename='plotly_utils.js') }}"></script>
<script src="{{ url_for('static', filename='image_card_common.js') }}"></script>
<script src="{{ url_for('static', filename='folder_selector.js') }}"></script>
<script defer src="{{ url_for('static', filename='grid.js') }}"></script>
{% endblock %}

{% block body %}
{% set heading_title = experiment.title if experiment.title != "Untitled" else "Untitled" %}
<h3 class="mb-4">{{ heading_title }} <small class="text-muted">({{ experiment.id }})</small></h3>

<div class="mb-4">
    {% include '_folder_selector.html' with context %}
    <div class="compare-plot-wrapper">
        <div id="detail-plot" class="plot-area">
            {% if figure %}
            <p class="text-muted fst-italic">Loading plot...</p>
            {% else %}
            <p class="text-muted fst-italic">No metrics available for this experiment.</p>
            {% endif %}
        </div>
    </div>
</div>

<div class="mb-4">
    <div id="detail-rollout-preview" class="mt-0"></div>
</div>

{% if figure %}
<script>
    // Uses IMAGE_FOLDER_OPTIONS, IMAGE_FOLDER_DESCRIPTIONS, getImageOption,
    // getImageDisplayTitle, getImageDescription, buildImagePreviewCard,
    // initializeImageCardTooltips from image_card_common.js
    // Uses createFolderSelector from folder_selector.js

                let lastPreviewStep = null;
                let detailStickyInitialized = false;
                let folderSelector = null;

                function getSelectedFolders() {
                    return folderSelector ? folderSelector.getSelectedFolders() : ["vis_fixed_0"];
                }

                function initializeDetailStickyPlot() {
                    if (detailStickyInitialized) return;
                    const wrapper = document.querySelector(".compare-plot-wrapper");
                    const plot = document.getElementById("detail-plot");
                    if (!wrapper || !plot) return;
                    detailStickyInitialized = true;
                    let isSticky = false;
                    let ticking = false;
                    const shrinkHeight = 240;
                    const placeholder = document.createElement("div");
                    placeholder.style.display = "none";
                    wrapper.parentNode.insertBefore(placeholder, wrapper);

                    const updateSticky = () => {
                        ticking = false;
                        const anchor = isSticky ? placeholder : wrapper;
                        const rect = anchor.getBoundingClientRect();
                        const shouldStick = rect.bottom <= shrinkHeight;
                        if (shouldStick !== isSticky) {
                            // Capture height BEFORE changing sticky state
                            const heightBeforeChange = isSticky ? null : wrapper.getBoundingClientRect().height;
                            isSticky = shouldStick;
                            wrapper.classList.toggle("sticky-active", isSticky);
                            if (isSticky) {
                                placeholder.style.height = `${heightBeforeChange}px`;
                                placeholder.style.display = "block";
                            } else {
                                placeholder.style.display = "none";
                                placeholder.style.height = "";
                                wrapper.style.left = "";
                                wrapper.style.width = "";
                            }
                            if (window.Plotly && Plotly.Plots && typeof Plotly.Plots.resize === "function") {
                                requestAnimationFrame(() => Plotly.Plots.resize(plot));
                            }
                        }
                        if (isSticky) {
                            wrapper.style.left = `${rect.left}px`;
                            wrapper.style.width = `${rect.width}px`;
                        }
                        wrapper.classList.toggle("sticky-shrink", isSticky);
                    };

                    const onScroll = () => {
                        if (!ticking) {
                            ticking = true;
                            requestAnimationFrame(updateSticky);
                        }
                    };

                    updateSticky();
                    window.addEventListener("scroll", onScroll, { passive: true });
                    window.addEventListener("resize", onScroll);
                }

                document.addEventListener("DOMContentLoaded", () => {
                    const figure = {{ figure|tojson }};
                    const rolloutSteps = {{ experiment.rollout_steps|tojson }};
                    const visualizationSteps = {{ visualization_steps|tojson }};
                    const expId = "{{ experiment.id }}";
                    const plotEl = document.getElementById("detail-plot");

                    const rebuildAndUpdate = () => {
                        buildPreviewGrid(expId, getSelectedFolders());
                        updatePreviewsAtStep(lastPreviewStep, rolloutSteps, visualizationSteps);
                    };

                    // Initialize shared folder selector (handles URL restoration internally)
                    folderSelector = createFolderSelector({
                        menuId: "folder-menu",
                        onSelectionChange: rebuildAndUpdate,
                    });

                    // Parse view state from URL
                    const urlParams = new URLSearchParams(window.location.search);
                    const xMin = urlParams.get("xmin");
                    const xMax = urlParams.get("xmax");
                    const yMin = urlParams.get("ymin");
                    const yMax = urlParams.get("ymax");

                    // Apply saved view state to figure layout
                    if (xMin !== null && xMax !== null) {
                        figure.layout.xaxis = figure.layout.xaxis || {};
                        figure.layout.xaxis.range = [parseFloat(xMin), parseFloat(xMax)];
                        figure.layout.xaxis.autorange = false;
                    }
                    if (yMin !== null && yMax !== null) {
                        figure.layout.yaxis = figure.layout.yaxis || {};
                        figure.layout.yaxis.range = [parseFloat(yMin), parseFloat(yMax)];
                        figure.layout.yaxis.autorange = false;
                    }

                    Plotly.react(plotEl, figure.data, figure.layout, buildPlotlyConfig(figure.config || {})).then(() => {
                        initializeDetailStickyPlot();
                        attachRolloutPreview(plotEl, expId, rolloutSteps, visualizationSteps);

                        // Save view state to URL on zoom/pan
                        plotEl.on("plotly_relayout", (eventData) => {
                            if (!eventData) return;
                            const url = new URL(window.location.href);

                            if (eventData["xaxis.autorange"] || eventData["yaxis.autorange"]) {
                                url.searchParams.delete("xmin");
                                url.searchParams.delete("xmax");
                                url.searchParams.delete("ymin");
                                url.searchParams.delete("ymax");
                            } else {
                                if (eventData["xaxis.range[0]"] !== undefined) {
                                    url.searchParams.set("xmin", eventData["xaxis.range[0]"]);
                                    url.searchParams.set("xmax", eventData["xaxis.range[1]"]);
                                }
                                if (eventData["yaxis.range[0]"] !== undefined) {
                                    url.searchParams.set("ymin", eventData["yaxis.range[0]"]);
                                    url.searchParams.set("ymax", eventData["yaxis.range[1]"]);
                                }
                            }

                            window.history.replaceState({}, "", url.toString());
                        });
                    });
                });

                function resolveFolderSpec(folderValue, vizSteps) {
                    const opt = getImageOption(folderValue);
                    if (!opt) {
                        return { key: folderValue, folder: folderValue, prefix: "rollout_" };
                    }
                    const candidates = getImageCandidates(opt);
                    for (let i = 0; i < candidates.length; i++) {
                        const candidate = candidates[i];
                        if (vizSteps && Array.isArray(vizSteps[candidate.key]) && vizSteps[candidate.key].length) {
                            return { key: candidate.key, folder: candidate.folder, prefix: candidate.prefix };
                        }
                    }
                    if (candidates.length) {
                        return { key: candidates[0].key, folder: candidates[0].folder, prefix: candidates[0].prefix };
                    }
                    return { key: folderValue, folder: opt.folder || opt.value, prefix: opt.prefix };
                }

                function nearestStepAtOrBelow(target, list) {
                    if (!Array.isArray(list) || list.length === 0) return null;
                    let best = null;
                    for (let i = 0; i < list.length; i++) {
                        const step = list[i];
                        if (step > target) continue;
                        if (best === null || step > best) best = step;
                    }
                    return best;
                }

                let currentPreviewMap = {};

                // Build the DOM structure once - called when folder selection changes
                function buildPreviewGrid(expId, folders) {
                    const preview = document.getElementById("detail-rollout-preview");
                    if (!preview) return;

                    preview.innerHTML = "";
                    currentPreviewMap = {};
                    const imagesPerRow = 3;

                    for (let rowStart = 0; rowStart < folders.length; rowStart += imagesPerRow) {
                        const rowFolders = folders.slice(rowStart, rowStart + imagesPerRow);
                        const row = document.createElement("div");
                        row.className = "detail-preview-row";

                        rowFolders.forEach((folderValue) => {
                            const cell = document.createElement("div");
                            cell.className = "detail-preview-cell";
                            cell.dataset.folderValue = folderValue;

                            // Use common card builder from image_card_common.js
                            const { card, stepLabelEl, img, missing } = buildImagePreviewCard({
                                folderValue,
                                showStepLabel: true,
                                initialStep: "—"
                            });

                            cell.appendChild(card);
                            row.appendChild(cell);

                            // Store references for later updates
                            currentPreviewMap[folderValue] = {
                                cell,
                                card,
                                stepLabelEl,
                                img,
                                missing,
                                folderValue,
                                expId
                            };
                        });

                        preview.appendChild(row);
                    }

                    // Initialize tooltips for newly created elements
                    initializeImageCardTooltips(preview);
                }

                // Update existing elements with new step data - called on hover
                function updatePreviewsAtStep(step, rolloutSteps, vizSteps) {
                    Object.values(currentPreviewMap).forEach((preview) => {
                        const { img, missing, folderValue, expId, stepLabelEl } = preview;
                        const spec = resolveFolderSpec(folderValue, vizSteps || {});
                        const folderSteps = (vizSteps && vizSteps[spec.key]) || (vizSteps && vizSteps.__fallback) || rolloutSteps || [];
                        const target = step !== null ? Math.max(0, Math.round(step)) : (folderSteps.length ? folderSteps[folderSteps.length - 1] : null);
                        const matched = target !== null ? nearestStepAtOrBelow(target, folderSteps) : null;

                        // Update step label in card header
                        if (stepLabelEl) {
                            stepLabelEl.textContent = matched !== null ? matched.toLocaleString() : "—";
                        }

                        if (matched !== null) {
                            const filename = `${spec.prefix}${matched.toString().padStart(7, "0")}.png`;
                            const src = `/assets/${expId}/${spec.folder}/${filename}`;

                            // Only update src if it changed
                            if (img.src !== src) {
                                img.src = src;
                                img.alt = `${spec.folder} ${matched}`;
                            }
                            img.classList.remove("d-none");
                            missing.classList.add("d-none");

                            img.onerror = () => {
                                img.classList.add("d-none");
                                missing.textContent = `No image for step ${matched}`;
                                missing.classList.remove("d-none");
                            };
                            img.onload = () => {
                                missing.classList.add("d-none");
                            };
                        } else {
                            img.classList.add("d-none");
                            missing.textContent = "No images available.";
                            missing.classList.remove("d-none");
                        }
                    });
                }

                function attachRolloutPreview(plotEl, expId, rolloutSteps, vizSteps) {
                    if (!plotEl || typeof Plotly === "undefined") return;

                    // Build initial grid structure
                    buildPreviewGrid(expId, getSelectedFolders());

                    const renderLatest = () => {
                        const folders = getSelectedFolders();
                        const folderValue = folders[0] || "vis_fixed_0";
                        const spec = resolveFolderSpec(folderValue, vizSteps || {});
                        const stepsForFolder = (vizSteps && vizSteps[spec.key]) || (vizSteps && vizSteps.__fallback) || rolloutSteps || [];
                        const lastStep = Array.isArray(stepsForFolder) && stepsForFolder.length
                            ? stepsForFolder[stepsForFolder.length - 1]
                            : null;
                        if (lastStep !== null) {
                            lastPreviewStep = lastStep;
                            updatePreviewsAtStep(lastStep, rolloutSteps, vizSteps);
                            return;
                        }
                        const allX = Array.isArray(plotEl.data)
                            ? plotEl.data.flatMap((trace) => Array.isArray(trace.x) ? trace.x : []).filter((v) => v !== null && v !== undefined)
                            : [];
                        if (allX.length) {
                            const latest = Math.max(...allX.map((v) => Number(v) || 0));
                            lastPreviewStep = latest;
                            updatePreviewsAtStep(latest, rolloutSteps, vizSteps);
                        }
                    };

                    plotEl.on("plotly_hover", (event) => {
                        const point = event?.points?.[0];
                        if (!point || typeof point.x === "undefined") return;
                        lastPreviewStep = point.x;
                        updatePreviewsAtStep(point.x, rolloutSteps, vizSteps);
                    });

                    renderLatest();
                }
</script>
{% endif %}

        <div class="table-responsive">
            <table class="table table-bordered align-top exp-table">
                <colgroup>
                    <col data-col-id="notes">
                    <col data-col-id="name">
                    <col data-col-id="metadata">
                    <col data-col-id="metadata_git">
                    <col data-col-id="image">
                </colgroup>
                <thead class="table-light">
                <tr>
                    <th data-col-id="notes">Notes</th>
                    <th data-col-id="name">Experiment</th>
                    <th data-col-id="metadata">metadata.txt</th>
                    <th data-col-id="metadata_git">metadata_git.txt</th>
                    <th data-col-id="image">metrics/loss_curves.png</th>
                </tr>
                </thead>
                <tbody>
                <tr data-exp-id="{{ experiment.id }}">
                    <td class="notes-cell" data-col-id="notes">
                        <form class="notes-form d-flex flex-column h-100" data-exp-id="{{ experiment.id }}">
                            <textarea class="form-control font-monospace flex-grow-1 mb-2" rows="6" placeholder="Add experiment notes...">{{- experiment.notes_text -}}</textarea>
                            <div class="d-flex align-items-center gap-2">
                                <button type="button" class="btn btn-primary btn-sm save-notes">Save</button>
                                <span class="notes-status small text-muted" aria-live="polite"></span>
                            </div>
                        </form>
                    </td>
                    <td data-col-id="name" class="experiment-cell">
                        {% set title_value = "" if experiment.title == "Untitled" else experiment.title %}
                        <form class="title-form inline-field-form inline-field-group" data-exp-id="{{ experiment.id }}">
                            <div class="input-group input-group-sm title-input-group inline-field-group w-100">
                                <input
                                    type="text"
                                    class="form-control form-control-sm exp-title-input inline-field"
                                    value="{{ title_value }}"
                                    placeholder="Untitled"
                                    aria-label="Experiment title"
                                    readonly
                                >
                            </div>
                            <span class="title-status small text-muted" aria-live="polite"></span>
                        </form>
                        <div class="fw-semibold">{{ experiment.name }}</div>
                        <div class="font-monospace text-muted small mt-1">{{ experiment.git_commit }}</div>
                        <div class="text-muted small mt-1">
                            Parameters: <span class="font-monospace format-params" data-value="{{ experiment.total_params if experiment.total_params is not none else '' }}">-</span>
                        </div>
                        <div class="text-muted small">
                            FLOPs/step: <span class="font-monospace format-flops" data-value="{{ experiment.flops_per_step if experiment.flops_per_step is not none else '' }}">-</span>
                        </div>
                    </td>
                    <td data-col-id="metadata">
                        <div class="metadata-wrapper card card-body p-2" data-exp-id="{{ experiment.id }}">
                            <pre class="metadata-block">{{ experiment.metadata_text }}</pre>
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-secondary mt-2 metadata-toggle" data-target="{{ experiment.id }}">Expand</button>
                    </td>
                    <td data-col-id="metadata_git">
                        <div class="metadata-wrapper card card-body p-2" data-exp-id="{{ experiment.id }}-git">
                            <pre class="metadata-block">{{ experiment.git_metadata_text }}</pre>
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-secondary mt-2 metadata-toggle" data-target="{{ experiment.id }}-git">Expand</button>
                    </td>
                    <td class="image-cell" data-col-id="image">
                        {% if experiment.loss_image %}
                        <img src="{{ url_for('serve_asset', relative_path=experiment.id ~ '/metrics/loss_curves.png') }}" alt="Loss curves for {{ experiment.name }}" class="img-fluid rounded border h-100 w-100 object-fit-contain">
                        {% else %}
                        <div class="text-muted fst-italic">metrics/loss_curves.png missing</div>
                        {% endif %}
                    </td>
                </tr>
                </tbody>
            </table>
        </div>
{% endblock %}
