{% extends "base.html" %}

{% block extra_head %}
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<script src="{{ url_for('static', filename='plotly_utils.js') }}"></script>
<script defer src="{{ url_for('static', filename='grid.js') }}"></script>
{% endblock %}

{% block body %}
{% set heading_title = experiment.title if experiment.title != "Untitled" else "Untitled" %}
<h3 class="mb-4">{{ heading_title }} <small class="text-muted">({{ experiment.id }})</small></h3>

<div class="card mb-4">
    <div class="card-body">
        <div class="d-flex flex-column flex-lg-row gap-3">
            <div class="flex-grow-1">
                <div class="compare-plot-controls-row detail-image-folder-actions">
                    <div class="comparison-action-group">
                        <button
                            type="button"
                            class="btn btn-outline-primary btn-sm"
                            data-folder-preset="rollout"
                        >Rollout</button>
                    </div>
                    <div class="comparison-action-group">
                        <div class="btn-group" role="group" aria-label="Action presets">
                            <span class="text-muted small comparison-action-label">Action</span>
                            <button
                                type="button"
                                class="btn btn-outline-primary btn-sm comparison-action-first"
                                data-folder-preset="z"
                            >Z</button>
                            <button
                                type="button"
                                class="btn btn-outline-primary btn-sm"
                                data-folder-preset="h"
                            >H</button>
                            <button
                                type="button"
                                class="btn btn-outline-primary btn-sm"
                                data-folder-preset="s"
                            >S</button>
                        </div>
                    </div>
                    <div class="dropdown detail-folder-dropdown">
                        <button
                            class="btn btn-outline-primary btn-sm dropdown-toggle"
                            type="button"
                            id="detail-folder-dropdown"
                            data-bs-toggle="dropdown"
                            data-bs-auto-close="outside"
                            aria-expanded="false"
                        >+ more</button>
                        <div
                            class="dropdown-menu p-2 detail-folder-menu"
                            aria-labelledby="detail-folder-dropdown"
                            id="detail-folder-menu"
                        ></div>
                    </div>
                </div>
                <div class="compare-plot-wrapper">
                    <div id="detail-plot" class="plot-area">
                        {% if figure %}
                        <p class="text-muted fst-italic">Loading plot...</p>
                        {% else %}
                        <p class="text-muted fst-italic">No metrics available for this experiment.</p>
                        {% endif %}
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="mb-4">
    <div class="small text-muted rollout-path mb-2">Hover a point to preview rollout.</div>
    <div id="detail-rollout-preview" class="mt-0"></div>
</div>

{% if figure %}
<script>
    const IMAGE_FOLDER_OPTIONS = [
                    { value: "vis_fixed_0", label: "Rollouts:Fixed 0", prefix: "rollout_", folder: "vis_fixed_0" },
                    { value: "vis_fixed_1", label: "Rollouts:Fixed 1", prefix: "rollout_", folder: "vis_fixed_1" },
                    { value: "vis_rolling_0", label: "Rollouts:Rolling 0", prefix: "rollout_", folder: "vis_rolling_0" },
                    { value: "vis_rolling_1", label: "Rollouts:Rolling 1", prefix: "rollout_", folder: "vis_rolling_1" },
                    { value: "pca_z", label: "Diagnostics:PCA (Z)", prefix: "pca_z_", folder: "pca_z", legacyPrefix: "embeddings_", legacyFolder: "embeddings" },
                    { value: "pca_s", label: "Diagnostics:PCA (S)", prefix: "pca_s_", folder: "pca_s" },
                    { value: "pca_h", label: "Diagnostics:PCA (H)", prefix: "pca_h_", folder: "pca_h" },
                    { value: "samples_hard", label: "Samples:Hard", prefix: "hard_", folder: "samples_hard" },
                    { value: "vis_self_distance_z", label: "Self-distance:Distance (Z)", prefix: "self_distance_z_", folder: "vis_self_distance_z" },
                    { value: "vis_self_distance_s", label: "Self-distance:Distance (S)", prefix: "self_distance_s_", folder: "vis_self_distance_s" },
                    { value: "vis_self_distance_h", label: "Self-distance:Distance (H)", prefix: "self_distance_h_", folder: "vis_self_distance_h" },
                    { value: "vis_delta_z_pca", label: "Diagnostics:Delta-z PCA", prefix: "delta_z_pca_", folder: "vis_delta_z_pca" },
                    { value: "vis_delta_s_pca", label: "Diagnostics:Delta-s PCA", prefix: "delta_s_pca_", folder: "vis_delta_s_pca" },
                    { value: "vis_delta_h_pca", label: "Diagnostics:Delta-h PCA", prefix: "delta_h_pca_", folder: "vis_delta_h_pca" },
                    { value: "vis_odometry_current_z", label: "Odometry:Cumulative sum of Δz PCA/ICA/t-SNE", prefix: "odometry_z_", folder: "vis_odometry" },
                    { value: "vis_odometry_current_s", label: "Odometry:Cumulative sum of Δs PCA/ICA/t-SNE", prefix: "odometry_s_", folder: "vis_odometry" },
                    { value: "vis_odometry_current_h", label: "Odometry:Cumulative sum of Δh PCA/ICA/t-SNE", prefix: "odometry_h_", folder: "vis_odometry" },
                    { value: "vis_odometry_z_vs_z_hat", label: "Odometry:||z - z_hat|| + scatter", prefix: "z_vs_z_hat_", folder: "vis_odometry" },
                    { value: "vis_odometry_s_vs_s_hat", label: "Odometry:||s - s_hat|| + scatter", prefix: "s_vs_s_hat_", folder: "vis_odometry" },
                    { value: "vis_odometry_h_vs_h_hat", label: "Odometry:||h - h_hat|| + scatter", prefix: "h_vs_h_hat_", folder: "vis_odometry" },
                    { value: "vis_action_alignment_detail", label: "Diagnostics:Action alignment (Z)", prefix: "action_alignment_detail_", folder: "vis_action_alignment_z" },
                    { value: "vis_action_alignment_detail_s", label: "Diagnostics:Action alignment (S)", prefix: "action_alignment_detail_", folder: "vis_action_alignment_s" },
                    { value: "vis_action_alignment_detail_h", label: "Diagnostics:Action alignment (H)", prefix: "action_alignment_detail_", folder: "vis_action_alignment_h" },
                    { value: "vis_ctrl_smoothness_z", label: "Vis v Ctrl:Local smoothness (Z)", prefix: "smoothness_z_", folder: "vis_vis_ctrl" },
                    { value: "vis_ctrl_smoothness_s", label: "Vis v Ctrl:Local smoothness (S)", prefix: "smoothness_s_", folder: "vis_vis_ctrl" },
                    { value: "vis_ctrl_smoothness_h", label: "Vis v Ctrl:Local smoothness (H)", prefix: "smoothness_h_", folder: "vis_vis_ctrl" },
                    { value: "vis_ctrl_composition_z", label: "Vis v Ctrl:Two-step composition error (Z)", prefix: "composition_error_z_", folder: "vis_vis_ctrl" },
                    { value: "vis_ctrl_composition_s", label: "Vis v Ctrl:Two-step composition error (S)", prefix: "composition_error_s_", folder: "vis_vis_ctrl" },
                    { value: "vis_ctrl_composition_h", label: "Vis v Ctrl:Two-step composition error (H)", prefix: "composition_error_h_", folder: "vis_vis_ctrl" },
                    { value: "vis_ctrl_stability_z", label: "Vis v Ctrl:Neighborhood stability (Z)", prefix: "stability_z_", folder: "vis_vis_ctrl" },
                    { value: "vis_ctrl_stability_s", label: "Vis v Ctrl:Neighborhood stability (S)", prefix: "stability_s_", folder: "vis_vis_ctrl" },
                    { value: "vis_ctrl_stability_h", label: "Vis v Ctrl:Neighborhood stability (H)", prefix: "stability_h_", folder: "vis_vis_ctrl" },
                    { value: "vis_cycle_error", label: "Diagnostics:Cycle error (Z)", prefix: "cycle_error_", folder: "vis_cycle_error_z" },
                    { value: "vis_cycle_error_s", label: "Diagnostics:Cycle error (S)", prefix: "cycle_error_", folder: "vis_cycle_error_s" },
                    { value: "vis_cycle_error_h", label: "Diagnostics:Cycle error (H)", prefix: "cycle_error_", folder: "vis_cycle_error_h" },
                    { value: "vis_graph_rank1_cdf_z", label: "Graph Diagnostics:Rank-1 CDF (Z)", prefix: "rank1_cdf_", folder: "graph_diagnostics_z" },
                    { value: "vis_graph_rank2_cdf_z", label: "Graph Diagnostics:Rank-2 CDF (Z)", prefix: "rank2_cdf_", folder: "graph_diagnostics_z" },
                    { value: "vis_graph_neff_violin_z", label: "Graph Diagnostics:Neighborhood size (Z)", prefix: "neff_violin_", folder: "graph_diagnostics_z" },
                    { value: "vis_graph_in_degree_hist_z", label: "Graph Diagnostics:In-degree (Z)", prefix: "in_degree_hist_", folder: "graph_diagnostics_z" },
                    { value: "vis_graph_edge_consistency_z", label: "Graph Diagnostics:Edge consistency (Z)", prefix: "edge_consistency_", folder: "graph_diagnostics_z" },
                    { value: "vis_graph_metrics_history_z", label: "Graph Diagnostics:Metrics history (Z)", prefix: "metrics_history_", folder: "graph_diagnostics_z" },
                    { value: "vis_graph_rank1_cdf_h", label: "Graph Diagnostics:Rank-1 CDF (H)", prefix: "rank1_cdf_", folder: "graph_diagnostics_h" },
                    { value: "vis_graph_rank2_cdf_h", label: "Graph Diagnostics:Rank-2 CDF (H)", prefix: "rank2_cdf_", folder: "graph_diagnostics_h" },
                    { value: "vis_graph_neff_violin_h", label: "Graph Diagnostics:Neighborhood size (H)", prefix: "neff_violin_", folder: "graph_diagnostics_h" },
                    { value: "vis_graph_in_degree_hist_h", label: "Graph Diagnostics:In-degree (H)", prefix: "in_degree_hist_", folder: "graph_diagnostics_h" },
                    { value: "vis_graph_edge_consistency_h", label: "Graph Diagnostics:Edge consistency (H)", prefix: "edge_consistency_", folder: "graph_diagnostics_h" },
                    { value: "vis_graph_metrics_history_h", label: "Graph Diagnostics:Metrics history (H)", prefix: "metrics_history_", folder: "graph_diagnostics_h" },
                    { value: "vis_graph_rank1_cdf_s", label: "Graph Diagnostics:Rank-1 CDF (S)", prefix: "rank1_cdf_", folder: "graph_diagnostics_s" },
                    { value: "vis_graph_rank2_cdf_s", label: "Graph Diagnostics:Rank-2 CDF (S)", prefix: "rank2_cdf_", folder: "graph_diagnostics_s" },
                    { value: "vis_graph_neff_violin_s", label: "Graph Diagnostics:Neighborhood size (S)", prefix: "neff_violin_", folder: "graph_diagnostics_s" },
                    { value: "vis_graph_in_degree_hist_s", label: "Graph Diagnostics:In-degree (S)", prefix: "in_degree_hist_", folder: "graph_diagnostics_s" },
                    { value: "vis_graph_edge_consistency_s", label: "Graph Diagnostics:Edge consistency (S)", prefix: "edge_consistency_", folder: "graph_diagnostics_s" },
                    { value: "vis_graph_metrics_history_s", label: "Graph Diagnostics:Metrics history (S)", prefix: "metrics_history_", folder: "graph_diagnostics_s" },
                ].sort((a, b) => {
                    const groupA = a.label.split(":")[0].trim();
                    const groupB = b.label.split(":")[0].trim();
                    const groupCompare = groupA.localeCompare(groupB);
                    if (groupCompare !== 0) {
                        return groupCompare;
                    }
                    const labelCompare = a.label.localeCompare(b.label);
                    if (labelCompare !== 0) {
                        return labelCompare;
                    }
                    return a.value.localeCompare(b.value);
                });

                let selectedImageFolders = ["vis_fixed_0"];
                let lastPreviewStep = null;
                let detailStickyInitialized = false;

                function getImageOption(folderValue) {
                    return IMAGE_FOLDER_OPTIONS.find((opt) => opt.value === folderValue);
                }

                function normalizeSelectedFolders(values) {
                    const normalized = [];
                    const seen = new Set();
                    (values || []).forEach((value) => {
                        const trimmed = value.trim();
                        if (!trimmed || seen.has(trimmed)) return;
                        if (!getImageOption(trimmed)) return;
                        seen.add(trimmed);
                        normalized.push(trimmed);
                    });
                    return normalized;
                }

                function updateFolderUrl(folders) {
                    const url = new URL(window.location.href);
                    const value = folders.join(",");
                    if (value) {
                        url.searchParams.set("folders", value);
                        url.searchParams.set("folder", folders[0]);
                    } else {
                        url.searchParams.delete("folders");
                        url.searchParams.delete("folder");
                    }
                    window.history.replaceState({}, "", url.toString());
                }

                function syncFolderDropdownSelection() {
                    const menu = document.getElementById("detail-folder-menu");
                    if (!menu) return;
                    const checkboxes = menu.querySelectorAll('input[type="checkbox"]');
                    checkboxes.forEach((checkbox) => {
                        checkbox.checked = selectedImageFolders.includes(checkbox.value);
                    });
                }

                function setSelectedFolders(nextSelected, { updateUrl = true } = {}) {
                    const normalized = normalizeSelectedFolders(nextSelected);
                    selectedImageFolders = normalized.length ? normalized : ["vis_fixed_0"];
                    if (updateUrl) {
                        updateFolderUrl(selectedImageFolders);
                    }
                    syncFolderDropdownSelection();
                }

                function mergeSelectionOrder(nextSelected) {
                    const normalized = normalizeSelectedFolders(nextSelected);
                    const nextSet = new Set(normalized);
                    const preserved = selectedImageFolders.filter((value) => nextSet.has(value));
                    const preservedSet = new Set(preserved);
                    const added = normalized.filter((value) => !preservedSet.has(value));
                    return preserved.concat(added);
                }

                function buildFolderDropdownItems() {
                    return IMAGE_FOLDER_OPTIONS.map((opt) => {
                        const item = document.createElement("label");
                        item.className = "dropdown-item d-flex align-items-center gap-2";
                        item.dataset.value = opt.value;
                        const checkbox = document.createElement("input");
                        checkbox.type = "checkbox";
                        checkbox.className = "form-check-input m-0";
                        checkbox.value = opt.value;
                        checkbox.checked = selectedImageFolders.includes(opt.value);
                        const text = document.createElement("span");
                        text.className = "small";
                        text.textContent = opt.label;
                        item.appendChild(checkbox);
                        item.appendChild(text);
                        return item;
                    });
                }

                function initializeFolderDropdown(onSelectionChange) {
                    const menu = document.getElementById("detail-folder-menu");
                    if (!menu) return;
                    menu.innerHTML = "";
                    const items = buildFolderDropdownItems();
                    items.forEach((item) => menu.appendChild(item));
                    menu.addEventListener("change", () => {
                        const nextSelected = Array.from(
                            menu.querySelectorAll('input[type="checkbox"]:checked')
                        ).map((checkbox) => checkbox.value);
                        const ordered = mergeSelectionOrder(nextSelected);
                        setSelectedFolders(ordered, { updateUrl: true });
                        if (onSelectionChange) onSelectionChange();
                    });
                }

                function initializeFolderPresetButtons(onSelectionChange) {
                    const presets = {
                        rollout: ["vis_fixed_0"],
                        z: ["vis_action_alignment_detail", "vis_self_distance_z", "vis_odometry_current_z"],
                        h: ["vis_action_alignment_detail_h", "vis_self_distance_h", "vis_odometry_current_h"],
                        s: ["vis_action_alignment_detail_s", "vis_self_distance_s", "vis_odometry_current_s"],
                    };
                    const buttons = document.querySelectorAll("[data-folder-preset]");
                    buttons.forEach((button) => {
                        button.addEventListener("click", () => {
                            const preset = presets[button.dataset.folderPreset];
                            if (!preset) return;
                            setSelectedFolders(preset, { updateUrl: true });
                            if (onSelectionChange) onSelectionChange();
                        });
                    });
                }

                function initializeDetailStickyPlot() {
                    if (detailStickyInitialized) return;
                    const wrapper = document.querySelector(".compare-plot-wrapper");
                    const plot = document.getElementById("detail-plot");
                    if (!wrapper || !plot) return;
                    detailStickyInitialized = true;
                    let isSticky = false;
                    let ticking = false;
                    const shrinkHeight = 240;
                    const placeholder = document.createElement("div");
                    placeholder.style.display = "none";
                    wrapper.parentNode.insertBefore(placeholder, wrapper);

                    const updateSticky = () => {
                        ticking = false;
                        const anchor = isSticky ? placeholder : wrapper;
                        const rect = anchor.getBoundingClientRect();
                        const shouldStick = rect.bottom <= shrinkHeight;
                        if (shouldStick !== isSticky) {
                            // Capture height BEFORE changing sticky state
                            const heightBeforeChange = isSticky ? null : wrapper.getBoundingClientRect().height;
                            isSticky = shouldStick;
                            wrapper.classList.toggle("sticky-active", isSticky);
                            if (isSticky) {
                                placeholder.style.height = `${heightBeforeChange}px`;
                                placeholder.style.display = "block";
                            } else {
                                placeholder.style.display = "none";
                                placeholder.style.height = "";
                                wrapper.style.left = "";
                                wrapper.style.width = "";
                            }
                            if (window.Plotly && Plotly.Plots && typeof Plotly.Plots.resize === "function") {
                                requestAnimationFrame(() => Plotly.Plots.resize(plot));
                            }
                        }
                        if (isSticky) {
                            wrapper.style.left = `${rect.left}px`;
                            wrapper.style.width = `${rect.width}px`;
                        }
                        wrapper.classList.toggle("sticky-shrink", isSticky);
                    };

                    const onScroll = () => {
                        if (!ticking) {
                            ticking = true;
                            requestAnimationFrame(updateSticky);
                        }
                    };

                    updateSticky();
                    window.addEventListener("scroll", onScroll, { passive: true });
                    window.addEventListener("resize", onScroll);
                }

                document.addEventListener("DOMContentLoaded", () => {
                    const figure = {{ figure|tojson }};
                    const rolloutSteps = {{ experiment.rollout_steps|tojson }};
                    const visualizationSteps = {{ visualization_steps|tojson }};
                    const expId = "{{ experiment.id }}";
                    const plotEl = document.getElementById("detail-plot");

                    // Restore folder selection from URL
                    const urlParams = new URLSearchParams(window.location.search);
                    const foldersParam = urlParams.get("folders");
                    if (foldersParam) {
                        setSelectedFolders(foldersParam.split(","), { updateUrl: false });
                    } else {
                        const folderParam = urlParams.get("folder");
                        if (folderParam) {
                            setSelectedFolders([folderParam], { updateUrl: false });
                        }
                    }

                    const rebuildAndUpdate = () => {
                        buildPreviewGrid(expId, selectedImageFolders);
                        updatePreviewsAtStep(lastPreviewStep, rolloutSteps, visualizationSteps);
                    };

                    initializeFolderDropdown(rebuildAndUpdate);
                    initializeFolderPresetButtons(rebuildAndUpdate);
                    syncFolderDropdownSelection();

                    // Parse view state from URL
                    const xMin = urlParams.get("xmin");
                    const xMax = urlParams.get("xmax");
                    const yMin = urlParams.get("ymin");
                    const yMax = urlParams.get("ymax");

                    // Apply saved view state to figure layout
                    if (xMin !== null && xMax !== null) {
                        figure.layout.xaxis = figure.layout.xaxis || {};
                        figure.layout.xaxis.range = [parseFloat(xMin), parseFloat(xMax)];
                        figure.layout.xaxis.autorange = false;
                    }
                    if (yMin !== null && yMax !== null) {
                        figure.layout.yaxis = figure.layout.yaxis || {};
                        figure.layout.yaxis.range = [parseFloat(yMin), parseFloat(yMax)];
                        figure.layout.yaxis.autorange = false;
                    }

                    Plotly.react(plotEl, figure.data, figure.layout, buildPlotlyConfig(figure.config || {})).then(() => {
                        initializeDetailStickyPlot();
                        attachRolloutPreview(plotEl, expId, rolloutSteps, visualizationSteps);

                        // Save view state to URL on zoom/pan
                        plotEl.on("plotly_relayout", (eventData) => {
                            if (!eventData) return;
                            const url = new URL(window.location.href);

                            if (eventData["xaxis.autorange"] || eventData["yaxis.autorange"]) {
                                url.searchParams.delete("xmin");
                                url.searchParams.delete("xmax");
                                url.searchParams.delete("ymin");
                                url.searchParams.delete("ymax");
                            } else {
                                if (eventData["xaxis.range[0]"] !== undefined) {
                                    url.searchParams.set("xmin", eventData["xaxis.range[0]"]);
                                    url.searchParams.set("xmax", eventData["xaxis.range[1]"]);
                                }
                                if (eventData["yaxis.range[0]"] !== undefined) {
                                    url.searchParams.set("ymin", eventData["yaxis.range[0]"]);
                                    url.searchParams.set("ymax", eventData["yaxis.range[1]"]);
                                }
                            }

                            window.history.replaceState({}, "", url.toString());
                        });
                    });
                });

                function resolveFolderSpec(folderValue, vizSteps) {
                    const opt = getImageOption(folderValue);
                    if (!opt) {
                        return { key: folderValue, folder: folderValue, prefix: "rollout_" };
                    }
                    const directSteps = vizSteps && vizSteps[folderValue];
                    if (
                        opt.legacyFolder
                        && (!Array.isArray(directSteps) || !directSteps.length)
                        && vizSteps
                        && Array.isArray(vizSteps[opt.legacyFolder])
                        && vizSteps[opt.legacyFolder].length
                    ) {
                        return {
                            key: opt.legacyFolder,
                            folder: opt.legacyFolder,
                            prefix: opt.legacyPrefix || opt.prefix,
                        };
                    }
                    return { key: folderValue, folder: opt.folder || opt.value, prefix: opt.prefix };
                }

                function nearestStepAtOrBelow(target, list) {
                    if (!Array.isArray(list) || list.length === 0) return null;
                    let best = null;
                    for (let i = 0; i < list.length; i++) {
                        const step = list[i];
                        if (step > target) continue;
                        if (best === null || step > best) best = step;
                    }
                    return best;
                }

                let currentPreviewMap = {};

                // Build the DOM structure once - called when folder selection changes
                function buildPreviewGrid(expId, folders) {
                    const preview = document.getElementById("detail-rollout-preview");
                    if (!preview) return;

                    preview.innerHTML = "";
                    currentPreviewMap = {};
                    const imagesPerRow = 4;

                    for (let rowStart = 0; rowStart < folders.length; rowStart += imagesPerRow) {
                        const rowFolders = folders.slice(rowStart, rowStart + imagesPerRow);
                        const row = document.createElement("div");
                        row.className = "detail-preview-row";

                        rowFolders.forEach((folderValue) => {
                            const cell = document.createElement("div");
                            cell.className = "detail-preview-cell";
                            cell.dataset.folderValue = folderValue;

                            const label = getImageOption(folderValue)?.label || folderValue;
                            const title = document.createElement("div");
                            title.className = "detail-preview-title small";
                            title.textContent = label;

                            const img = document.createElement("img");
                            img.className = "img-fluid rounded border detail-preview-img d-none";
                            img.alt = "Preview";

                            const missing = document.createElement("div");
                            missing.className = "text-muted fst-italic small detail-preview-missing d-none";
                            missing.textContent = "No images available.";

                            cell.appendChild(title);
                            cell.appendChild(img);
                            cell.appendChild(missing);
                            row.appendChild(cell);

                            // Store references for later updates
                            currentPreviewMap[folderValue] = {
                                cell,
                                title,
                                img,
                                missing,
                                folderValue,
                                expId
                            };
                        });

                        preview.appendChild(row);
                    }
                }

                // Update existing elements with new step data - called on hover
                function updatePreviewsAtStep(step, rolloutSteps, vizSteps) {
                    const pathDisplay = document.querySelector(".rollout-path");
                    const folders = selectedImageFolders;

                    Object.values(currentPreviewMap).forEach((preview) => {
                        const { img, missing, folderValue, expId } = preview;
                        const spec = resolveFolderSpec(folderValue, vizSteps || {});
                        const folderSteps = (vizSteps && vizSteps[spec.key]) || (vizSteps && vizSteps.__fallback) || rolloutSteps || [];
                        const target = step !== null ? Math.max(0, Math.round(step)) : (folderSteps.length ? folderSteps[folderSteps.length - 1] : null);
                        const matched = target !== null ? nearestStepAtOrBelow(target, folderSteps) : null;

                        if (matched !== null) {
                            const filename = `${spec.prefix}${matched.toString().padStart(7, "0")}.png`;
                            const src = `/assets/${expId}/${spec.folder}/${filename}`;

                            // Only update src if it changed
                            if (img.src !== src) {
                                img.src = src;
                                img.alt = `${spec.folder} ${matched}`;
                            }
                            img.classList.remove("d-none");
                            missing.classList.add("d-none");

                            img.onerror = () => {
                                img.classList.add("d-none");
                                missing.textContent = `No image for step ${matched}`;
                                missing.classList.remove("d-none");
                            };
                            img.onload = () => {
                                missing.classList.add("d-none");
                            };
                        } else {
                            img.classList.add("d-none");
                            missing.textContent = "No images available.";
                            missing.classList.remove("d-none");
                        }
                    });

                    // Update path display
                    if (pathDisplay && folders.length > 0 && step !== null) {
                        const spec = resolveFolderSpec(folders[0], vizSteps || {});
                        const folderSteps = (vizSteps && vizSteps[spec.key]) || (vizSteps && vizSteps.__fallback) || rolloutSteps || [];
                        const target = Math.max(0, Math.round(step));
                        const matched = nearestStepAtOrBelow(target, folderSteps);
                        if (matched !== null) {
                            pathDisplay.textContent = `Hovered step ${target}, showing step ${matched}`;
                        } else {
                            pathDisplay.textContent = "No images available.";
                        }
                    }
                }

                function attachRolloutPreview(plotEl, expId, rolloutSteps, vizSteps) {
                    if (!plotEl || typeof Plotly === "undefined") return;

                    // Build initial grid structure
                    buildPreviewGrid(expId, selectedImageFolders);

                    const renderLatest = () => {
                        const folderValue = selectedImageFolders[0] || "vis_fixed_0";
                        const spec = resolveFolderSpec(folderValue, vizSteps || {});
                        const stepsForFolder = (vizSteps && vizSteps[spec.key]) || (vizSteps && vizSteps.__fallback) || rolloutSteps || [];
                        const lastStep = Array.isArray(stepsForFolder) && stepsForFolder.length
                            ? stepsForFolder[stepsForFolder.length - 1]
                            : null;
                        if (lastStep !== null) {
                            lastPreviewStep = lastStep;
                            updatePreviewsAtStep(lastStep, rolloutSteps, vizSteps);
                            return;
                        }
                        const allX = Array.isArray(plotEl.data)
                            ? plotEl.data.flatMap((trace) => Array.isArray(trace.x) ? trace.x : []).filter((v) => v !== null && v !== undefined)
                            : [];
                        if (allX.length) {
                            const latest = Math.max(...allX.map((v) => Number(v) || 0));
                            lastPreviewStep = latest;
                            updatePreviewsAtStep(latest, rolloutSteps, vizSteps);
                        }
                    };

                    plotEl.on("plotly_hover", (event) => {
                        const point = event?.points?.[0];
                        if (!point || typeof point.x === "undefined") return;
                        lastPreviewStep = point.x;
                        updatePreviewsAtStep(point.x, rolloutSteps, vizSteps);
                    });

                    renderLatest();
                }
</script>
{% endif %}

        <div class="table-responsive">
            <table class="table table-bordered align-top exp-table">
                <colgroup>
                    <col data-col-id="notes">
                    <col data-col-id="name">
                    <col data-col-id="metadata">
                    <col data-col-id="metadata_git">
                    <col data-col-id="image">
                </colgroup>
                <thead class="table-light">
                <tr>
                    <th data-col-id="notes">Notes</th>
                    <th data-col-id="name">Experiment</th>
                    <th data-col-id="metadata">metadata.txt</th>
                    <th data-col-id="metadata_git">metadata_git.txt</th>
                    <th data-col-id="image">metrics/loss_curves.png</th>
                </tr>
                </thead>
                <tbody>
                <tr data-exp-id="{{ experiment.id }}">
                    <td class="notes-cell" data-col-id="notes">
                        <form class="notes-form d-flex flex-column h-100" data-exp-id="{{ experiment.id }}">
                            <textarea class="form-control font-monospace flex-grow-1 mb-2" rows="6" placeholder="Add experiment notes...">{{- experiment.notes_text -}}</textarea>
                            <div class="d-flex align-items-center gap-2">
                                <button type="button" class="btn btn-primary btn-sm save-notes">Save</button>
                                <span class="notes-status small text-muted" aria-live="polite"></span>
                            </div>
                        </form>
                    </td>
                    <td data-col-id="name" class="experiment-cell">
                        {% set title_value = "" if experiment.title == "Untitled" else experiment.title %}
                        <form class="title-form inline-field-form inline-field-group" data-exp-id="{{ experiment.id }}">
                            <div class="input-group input-group-sm title-input-group inline-field-group w-100">
                                <input
                                    type="text"
                                    class="form-control form-control-sm exp-title-input inline-field"
                                    value="{{ title_value }}"
                                    placeholder="Untitled"
                                    aria-label="Experiment title"
                                    readonly
                                >
                            </div>
                            <span class="title-status small text-muted" aria-live="polite"></span>
                        </form>
                        <div class="fw-semibold">{{ experiment.name }}</div>
                        <div class="font-monospace text-muted small mt-1">{{ experiment.git_commit }}</div>
                        <div class="text-muted small mt-1">
                            Parameters: <span class="font-monospace format-params" data-value="{{ experiment.total_params if experiment.total_params is not none else '' }}">-</span>
                        </div>
                        <div class="text-muted small">
                            FLOPs/step: <span class="font-monospace format-flops" data-value="{{ experiment.flops_per_step if experiment.flops_per_step is not none else '' }}">-</span>
                        </div>
                    </td>
                    <td data-col-id="metadata">
                        <div class="metadata-wrapper card card-body p-2" data-exp-id="{{ experiment.id }}">
                            <pre class="metadata-block">{{ experiment.metadata_text }}</pre>
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-secondary mt-2 metadata-toggle" data-target="{{ experiment.id }}">Expand</button>
                    </td>
                    <td data-col-id="metadata_git">
                        <div class="metadata-wrapper card card-body p-2" data-exp-id="{{ experiment.id }}-git">
                            <pre class="metadata-block">{{ experiment.git_metadata_text }}</pre>
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-secondary mt-2 metadata-toggle" data-target="{{ experiment.id }}-git">Expand</button>
                    </td>
                    <td class="image-cell" data-col-id="image">
                        {% if experiment.loss_image %}
                        <img src="{{ url_for('serve_asset', relative_path=experiment.id ~ '/metrics/loss_curves.png') }}" alt="Loss curves for {{ experiment.name }}" class="img-fluid rounded border h-100 w-100 object-fit-contain">
                        {% else %}
                        <div class="text-muted fst-italic">metrics/loss_curves.png missing</div>
                        {% endif %}
                    </td>
                </tr>
                </tbody>
            </table>
        </div>
{% endblock %}
