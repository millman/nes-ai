{% extends "base.html" %}

{% block extra_head %}
<link rel="stylesheet" href="{{ url_for('static', filename='common_styles.css') }}">
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<script src="{{ url_for('static', filename='plotly_utils.js') }}"></script>
{% endblock %}

{% block body %}
<style>
.self-distance-plot {
    height: 240px;
    min-height: 240px;
    max-height: 260px;
}
</style>
<div class="d-flex align-items-center justify-content-between flex-wrap gap-2 mb-3">
    <div>
        {% if experiment %}
        <h3 class="mb-1">{{ experiment.title if experiment.title != "Untitled" else "Untitled" }} <small class="text-muted">({{ experiment.id }})</small></h3>
        {% else %}
        <h3 class="mb-1">{{ page_title if page_title is defined else "Self-distance (Z/H/P)" }}</h3>
        <div class="text-muted small">No experiments with self-distance outputs.</div>
        {% endif %}
    </div>
    {% if experiment %}
    <div class="d-flex align-items-center gap-2 flex-wrap">
        <a class="btn btn-outline-secondary btn-sm" href="{{ url_for('experiment_detail', exp_id=experiment.id) }}">Open experiment</a>
    </div>
    {% endif %}
</div>

{% if not experiment %}
<div class="text-muted fst-italic">No matching self-distance outputs found.</div>
{% else %}
{% if missing_parts %}
<div class="alert alert-warning py-2 small mb-2">
    Missing self-distance outputs: {{ missing_parts | join(", ") }}.
</div>
{% endif %}
<div class="small text-muted mb-2">
    Loaded from
    {% if experiment.self_distance_z_csv %}
        {{ experiment.self_distance_z_csv.name }}
    {% else %}
        <span class="text-warning">missing self_distance_z.csv</span>
    {% endif %},
    {% if self_distance_h_csv %}
        {{ self_distance_h_csv.name }}
    {% else %}
        <span class="text-warning">missing self_distance_h.csv</span>
    {% endif %},
    {% if self_distance_p_csv %}
        {{ self_distance_p_csv.name }}
    {% else %}
        <span class="text-warning">missing self_distance_p.csv</span>
    {% endif %}.
</div>
<ul class="nav nav-tabs" id="self-distance-plot-tabs" role="tablist">
    <li class="nav-item" role="presentation">
        <button class="nav-link active" id="self-distance-cos-tab" data-bs-toggle="tab" data-bs-target="#self-distance-cos-pane" type="button" role="tab" aria-controls="self-distance-cos-pane" aria-selected="true">Cosine distance</button>
    </li>
    <li class="nav-item" role="presentation">
        <button class="nav-link" id="self-distance-l2-tab" data-bs-toggle="tab" data-bs-target="#self-distance-l2-pane" type="button" role="tab" aria-controls="self-distance-l2-pane" aria-selected="false">L2 distance</button>
    </li>
</ul>
<div class="tab-content mt-2">
    <div class="tab-pane fade show active" id="self-distance-cos-pane" role="tabpanel" aria-labelledby="self-distance-cos-tab" tabindex="0">
        <div class="row gy-1 gx-3 mt-3">
            <div class="col-12 col-lg-4">
                <div id="self-distance-z-first-cos" class="plot-area self-distance-plot"></div>
            </div>
            <div class="col-12 col-lg-4">
                <div id="self-distance-h-first-cos" class="plot-area self-distance-plot"></div>
            </div>
            <div class="col-12 col-lg-4">
                <div id="self-distance-p-first-cos" class="plot-area self-distance-plot"></div>
            </div>
        </div>
        <div class="row gy-1 gx-3 mt-1">
            <div class="col-12 col-lg-4">
                <div id="self-distance-z-prior-cos" class="plot-area self-distance-plot"></div>
            </div>
            <div class="col-12 col-lg-4">
                <div id="self-distance-h-prior-cos" class="plot-area self-distance-plot"></div>
            </div>
            <div class="col-12 col-lg-4">
                <div id="self-distance-p-prior-cos" class="plot-area self-distance-plot"></div>
            </div>
        </div>
    </div>
    <div class="tab-pane fade" id="self-distance-l2-pane" role="tabpanel" aria-labelledby="self-distance-l2-tab" tabindex="0">
        <div class="row gy-1 gx-3 mt-3">
            <div class="col-12 col-lg-4">
                <div id="self-distance-z-first-l2" class="plot-area self-distance-plot"></div>
            </div>
            <div class="col-12 col-lg-4">
                <div id="self-distance-h-first-l2" class="plot-area self-distance-plot"></div>
            </div>
            <div class="col-12 col-lg-4">
                <div id="self-distance-p-first-l2" class="plot-area self-distance-plot"></div>
            </div>
        </div>
        <div class="row gy-1 gx-3 mt-1">
            <div class="col-12 col-lg-4">
                <div id="self-distance-z-prior-l2" class="plot-area self-distance-plot"></div>
            </div>
            <div class="col-12 col-lg-4">
                <div id="self-distance-h-prior-l2" class="plot-area self-distance-plot"></div>
            </div>
            <div class="col-12 col-lg-4">
                <div id="self-distance-p-prior-l2" class="plot-area self-distance-plot"></div>
            </div>
        </div>
    </div>
</div>
<div class="row g-3 mt-3" id="self-distance-frame-row">
    <div class="col-12 col-md-4">
        <div class="card h-100">
            <div class="card-header py-2">First frame</div>
            <div class="card-body d-flex flex-column align-items-center">
                <img id="self-distance-first-img" class="img-fluid rounded border d-none" alt="First frame preview">
                <div class="text-muted small mt-2" id="self-distance-first-label"></div>
                <div class="text-muted small" id="self-distance-first-action"></div>
            </div>
        </div>
    </div>
    <div class="col-12 col-md-4">
        <div class="card h-100">
            <div class="card-header py-2">Prior frame</div>
            <div class="card-body d-flex flex-column align-items-center">
                <img id="self-distance-prior-img" class="img-fluid rounded border d-none" alt="Prior frame preview">
                <div class="text-muted small mt-2" id="self-distance-prior-label"></div>
                <div class="text-muted small" id="self-distance-prior-action"></div>
            </div>
        </div>
    </div>
    <div class="col-12 col-md-4">
        <div class="card h-100">
            <div class="card-header py-2">Current frame</div>
            <div class="card-body d-flex flex-column align-items-center">
                <img id="self-distance-current-img" class="img-fluid rounded border d-none" alt="Current frame preview">
                <div class="text-muted small mt-2" id="self-distance-current-label"></div>
                <div class="text-muted small" id="self-distance-current-action"></div>
            </div>
        </div>
    </div>
</div>
<div class="d-flex align-items-center justify-content-between mb-2 mt-4">
    <h6 class="mb-0">Training metrics (loss)</h6>
</div>
<div class="plot-pin-wrapper mb-3" id="self-distance-loss-wrapper">
    <button
        type="button"
        class="plot-pin-btn"
        id="self-distance-loss-pin"
        aria-pressed="false"
        aria-label="Pin training metrics plot"
        title="Pin training metrics plot"
    >
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
            <path d="M4.146.146A.5.5 0 0 1 4.5 0h7a.5.5 0 0 1 .5.5c0 .68-.342 1.174-.646 1.479-.126.125-.25.224-.354.298v4.431l.078.048c.203.127.476.314.751.555C12.36 7.775 13 8.527 13 9.5a.5.5 0 0 1-.5.5h-4v4.5c0 .276-.224 1.5-.5 1.5s-.5-1.224-.5-1.5V10h-4a.5.5 0 0 1-.5-.5c0-.973.64-1.725 1.17-2.189A6 6 0 0 1 5 6.708V2.277a3 3 0 0 1-.354-.298C4.342 1.674 4 1.179 4 .5a.5.5 0 0 1 .146-.354"/>
        </svg>
    </button>
    <div id="self-distance-loss-plot" class="plot-pin-plot"></div>
</div>
<div class="row g-3 mt-3">
    <div class="col-12 col-lg-3">
        <div class="card h-100">
            <div class="card-header py-2 d-flex justify-content-between align-items-center">
                <span class="image-preview-card-title">Self-distance image (Z)</span>
                <div class="d-flex align-items-center gap-2">
                    <span class="text-muted small">Step: <span class="step-label-value" id="self-distance-step-label-z">—</span></span>
                    <span class="diagnostic-info-icon" data-bs-toggle="tooltip" data-bs-placement="left" title="Self-distance Z image over steps. Read: smoother trends mean stable latent dynamics. Good: consistent scale with few abrupt spikes or drift.">i</span>
                </div>
            </div>
            <div class="card-body d-flex flex-column gap-2 align-items-start">
                <img id="self-distance-step-img-z" class="img-fluid rounded border d-none" alt="Self-distance Z step">
            </div>
        </div>
    </div>
    <div class="col-12 col-lg-3">
        <div class="card h-100">
            <div class="card-header py-2 d-flex justify-content-between align-items-center">
                <span class="image-preview-card-title">Self-distance image (H)</span>
                <div class="d-flex align-items-center gap-2">
                    <span class="text-muted small">Step: <span class="step-label-value" id="self-distance-step-label-h">—</span></span>
                    <span class="diagnostic-info-icon" data-bs-toggle="tooltip" data-bs-placement="left" title="Self-distance H image over steps. Read: smoother trends mean stable dynamics state. Good: consistent scale with few abrupt spikes or drift.">i</span>
                </div>
            </div>
            <div class="card-body d-flex flex-column gap-2 align-items-start">
                <img id="self-distance-step-img-h" class="img-fluid rounded border d-none" alt="Self-distance H step">
            </div>
        </div>
    </div>
    <div class="col-12 col-lg-3">
        <div class="card h-100">
            <div class="card-header py-2 d-flex justify-content-between align-items-center">
                <span class="image-preview-card-title">Self-distance image (P)</span>
                <div class="d-flex align-items-center gap-2">
                    <span class="text-muted small">Step: <span class="step-label-value" id="self-distance-step-label-p">—</span></span>
                    <span class="diagnostic-info-icon" data-bs-toggle="tooltip" data-bs-placement="left" title="Self-distance P image over steps. Read: smoother trends mean stable geometry. Good: consistent scale with few abrupt spikes or drift.">i</span>
                </div>
            </div>
            <div class="card-body d-flex flex-column gap-2 align-items-start">
                <img id="self-distance-step-img-p" class="img-fluid rounded border d-none" alt="Self-distance P step">
            </div>
        </div>
    </div>
</div>
{% endif %}
{% endblock %}

{% block extra_scripts %}
{% if experiment %}
<script>
document.addEventListener("DOMContentLoaded", () => {
    if (typeof Plotly === "undefined") {
        const firstPlot = document.getElementById("self-distance-z-first-cos");
        if (firstPlot) {
            firstPlot.innerHTML = "<p class='text-danger small'>Plotly failed to load.</p>";
        }
        return;
    }
    const zCsvUrl = {% if experiment.self_distance_z_csv %}"{{ url_for('serve_asset', relative_path=experiment.id ~ '/' ~ experiment.self_distance_z_csv.relative_to(experiment.path)) }}"{% else %}null{% endif %};
    const hCsvUrl = {% if self_distance_h_csv %}"{{ url_for('serve_asset', relative_path=experiment.id ~ '/' ~ self_distance_h_csv.relative_to(experiment.path)) }}"{% else %}null{% endif %};
    const pCsvUrl = {% if self_distance_p_csv %}"{{ url_for('serve_asset', relative_path=experiment.id ~ '/' ~ self_distance_p_csv.relative_to(experiment.path)) }}"{% else %}null{% endif %};
    const plotConfig = buildPlotlyConfig({});
    const zFirstPlotCos = document.getElementById("self-distance-z-first-cos");
    const zPriorPlotCos = document.getElementById("self-distance-z-prior-cos");
    const hFirstPlotCos = document.getElementById("self-distance-h-first-cos");
    const hPriorPlotCos = document.getElementById("self-distance-h-prior-cos");
    const pFirstPlotCos = document.getElementById("self-distance-p-first-cos");
    const pPriorPlotCos = document.getElementById("self-distance-p-prior-cos");
    const zFirstPlotL2 = document.getElementById("self-distance-z-first-l2");
    const zPriorPlotL2 = document.getElementById("self-distance-z-prior-l2");
    const hFirstPlotL2 = document.getElementById("self-distance-h-first-l2");
    const hPriorPlotL2 = document.getElementById("self-distance-h-prior-l2");
    const pFirstPlotL2 = document.getElementById("self-distance-p-first-l2");
    const pPriorPlotL2 = document.getElementById("self-distance-p-prior-l2");
    const firstImg = document.getElementById("self-distance-first-img");
    const priorImg = document.getElementById("self-distance-prior-img");
    const currentImg = document.getElementById("self-distance-current-img");
    const firstLabel = document.getElementById("self-distance-first-label");
    const priorLabel = document.getElementById("self-distance-prior-label");
    const currentLabel = document.getElementById("self-distance-current-label");
    const firstAction = document.getElementById("self-distance-first-action");
    const priorAction = document.getElementById("self-distance-prior-action");
    const currentAction = document.getElementById("self-distance-current-action");
    const stepImgZ = document.getElementById("self-distance-step-img-z");
    const stepLabelZ = document.getElementById("self-distance-step-label-z");
    const stepImgH = document.getElementById("self-distance-step-img-h");
    const stepLabelH = document.getElementById("self-distance-step-label-h");
    const stepImgP = document.getElementById("self-distance-step-img-p");
    const stepLabelP = document.getElementById("self-distance-step-label-p");
    const diagLossPlot = document.getElementById("self-distance-loss-plot");
    const diagLossWrapper = document.getElementById("self-distance-loss-wrapper");
    const diagLossPin = document.getElementById("self-distance-loss-pin");
    const diagFigure = {{ figure | tojson if figure else 'null' }};

    const stepMapZ = {};
    const stepMapH = {};
    const stepMapP = {};
    {% if experiment.self_distance_z_images %}
    {% for img in experiment.self_distance_z_images %}
    {% if "cosine" not in img.stem %}
    {% set rel_img = img.relative_to(experiment.path) %}
    {% set stem = img.stem.split('_')|last %}
    {% set step = stem|int %}
    stepMapZ[{{ step }}] = "{{ url_for('serve_asset', relative_path=experiment.id ~ '/' ~ rel_img) }}";
    {% endif %}
    {% endfor %}
    {% endif %}
    {% if self_distance_h_images %}
    {% for img in self_distance_h_images %}
    {% set rel_img = img.relative_to(experiment.path) %}
    {% set stem = img.stem.split('_')|last %}
    {% set step = stem|int %}
    stepMapH[{{ step }}] = "{{ url_for('serve_asset', relative_path=experiment.id ~ '/' ~ rel_img) }}";
    {% endfor %}
    {% endif %}
    {% if self_distance_p_images %}
    {% for img in self_distance_p_images %}
    {% if "cosine" not in img.stem %}
    {% set rel_img = img.relative_to(experiment.path) %}
    {% set stem = img.stem.split('_')|last %}
    {% set step = stem|int %}
    stepMapP[{{ step }}] = "{{ url_for('serve_asset', relative_path=experiment.id ~ '/' ~ rel_img) }}";
    {% endif %}
    {% endfor %}
    {% endif %}
    let diagLossPinned = false;

    const assetPath = (rel) => `/assets/{{ experiment.id }}/${rel.replace(/^\/+/, "")}`;
    const setImage = (imgEl, labelEl, actionEl, relPath, labelText, actionText) => {
        if (!imgEl || !labelEl) return;
        if (!relPath) {
            imgEl.classList.add("d-none");
            labelEl.textContent = "";
            if (actionEl) actionEl.textContent = "Action: (not available)";
            return;
        }
        imgEl.src = assetPath(relPath);
        imgEl.alt = labelText || relPath;
        imgEl.classList.remove("d-none");
        labelEl.textContent = labelText || relPath;
        if (actionEl) {
            actionEl.textContent = actionText ? `Action: ${actionText}` : "Action: (not available)";
        }
    };

    const selfDistanceMapZ = {};
    {% if experiment.self_distance_z_images %}
    {% for img in experiment.self_distance_z_images %}
    {% if "cosine" not in img.stem %}
    {% set rel_img = img.relative_to(experiment.path) %}
    {% set stem = img.stem.split('_')|last %}
    {% set step = stem|int %}
    selfDistanceMapZ[{{ step }}] = {
        url: "{{ url_for('serve_asset', relative_path=experiment.id ~ '/' ~ rel_img) }}",
        path: "{{ rel_img }}",
    };
    {% endif %}
    {% endfor %}
    {% endif %}
    const selfDistanceStepsZ = Object.keys(selfDistanceMapZ).map((k) => Number(k)).filter((n) => !Number.isNaN(n)).sort((a, b) => a - b);

    const selfDistanceMapH = {};
    {% if self_distance_h_images %}
    {% for img in self_distance_h_images %}
    {% if "cosine" not in img.stem %}
    {% set rel_img = img.relative_to(experiment.path) %}
    {% set stem = img.stem.split('_')|last %}
    {% set step = stem|int %}
    selfDistanceMapH[{{ step }}] = {
        url: "{{ url_for('serve_asset', relative_path=experiment.id ~ '/' ~ rel_img) }}",
        path: "{{ rel_img }}",
    };
    {% endif %}
    {% endfor %}
    {% endif %}
    const selfDistanceStepsH = Object.keys(selfDistanceMapH).map((k) => Number(k)).filter((n) => !Number.isNaN(n)).sort((a, b) => a - b);

    const selfDistanceMapP = {};
    {% if self_distance_p_images %}
    {% for img in self_distance_p_images %}
    {% if "cosine" not in img.stem %}
    {% set rel_img = img.relative_to(experiment.path) %}
    {% set stem = img.stem.split('_')|last %}
    {% set step = stem|int %}
    selfDistanceMapP[{{ step }}] = {
        url: "{{ url_for('serve_asset', relative_path=experiment.id ~ '/' ~ rel_img) }}",
        path: "{{ rel_img }}",
    };
    {% endif %}
    {% endfor %}
    {% endif %}
    const selfDistanceStepsP = Object.keys(selfDistanceMapP).map((k) => Number(k)).filter((n) => !Number.isNaN(n)).sort((a, b) => a - b);

    const nearestSelfStep = (step, steps) => {
        if (!steps.length) return null;
        let best = steps[0];
        let bestDiff = Math.abs(step - steps[0]);
        for (let i = 1; i < steps.length; i++) {
            const diff = Math.abs(step - steps[i]);
            if (diff < bestDiff) {
                bestDiff = diff;
                best = steps[i];
            }
        }
        return best;
    };

    const updateSelfDistanceImage = (step, map, steps, imgEl, labelEl, label) => {
        if (!imgEl || !labelEl) return;
        const nearest = nearestSelfStep(step, steps);
        if (nearest === null || !map[nearest]) {
            imgEl.classList.add("d-none");
            labelEl.textContent = "—";
            return;
        }
        const entry = map[nearest];
        imgEl.src = entry.url;
        imgEl.alt = `Self-distance ${label} step ${nearest}`;
        imgEl.classList.remove("d-none");
        labelEl.textContent = nearest;
    };

    const buildActionMap = (rows) => {
        const map = {};
        rows.forEach((row) => {
            const trajectory = row.trajectory || row.trajectory_label || "trajectory";
            const step = Number(row.timestep);
            if (!Number.isFinite(step)) return;
            const actionLabel = row.action_label || "";
            if (!map[trajectory]) {
                map[trajectory] = { firstStep: step, firstAction: actionLabel, actions: {} };
            }
            map[trajectory].actions[step] = actionLabel;
            if (step < map[trajectory].firstStep) {
                map[trajectory].firstStep = step;
                map[trajectory].firstAction = actionLabel;
            }
        });
        return map;
    };

    const getFirstAction = (actionMap, trajectory, fallback) => {
        const entry = actionMap[trajectory];
        if (entry && entry.firstAction) return entry.firstAction;
        return fallback || "";
    };

    const getPriorAction = (actionMap, trajectory, step, fallback) => {
        const entry = actionMap[trajectory];
        if (!entry) return fallback || "";
        const priorStep = Number(step) - 1;
        if (Number.isFinite(priorStep) && entry.actions && entry.actions[priorStep]) {
            return entry.actions[priorStep];
        }
        if (Number.isFinite(entry.firstStep) && Number.isFinite(step) && step <= entry.firstStep) {
            return entry.firstAction || fallback || "";
        }
        return fallback || "";
    };

    const attachHover = (plotEl, actionMap) => {
        plotEl.on("plotly_hover", (event) => {
            const point = event?.points?.[0];
            if (!point || !point.customdata) return;
            const payload = point.customdata;
            const trajectory = payload[0];
            const step = payload[1];
            const framePath = payload[2];
            const firstPath = payload[3];
            const priorPath = payload[4];
            const frameLabelText = payload[5] || `t=${step}`;
            const headerText = `${trajectory} • t=${step}`;
            const actionText = payload[6] || "";
            const firstActionText = getFirstAction(actionMap, trajectory, actionText);
            const priorActionText = getPriorAction(actionMap, trajectory, step, actionText);

            setImage(firstImg, firstLabel, firstAction, firstPath, `first: ${frameLabelText}`, firstActionText);
            setImage(priorImg, priorLabel, priorAction, priorPath, `prior: t=${Math.max(0, step - 1)}`, priorActionText);
            setImage(currentImg, currentLabel, currentAction, framePath, headerText, actionText);
        });
    };

    const cosineFirstColor = "#3b6fb6";
    const cosinePriorColor = "#3e8f3e";

    const buildCosinePlots = (rows, firstEl, priorEl, label, axisLabel, titlePrefix) => {
        if (!rows.length) {
            if (firstEl) firstEl.innerHTML = `<p class='text-muted fst-italic'>No rows in ${label} CSV.</p>`;
            if (priorEl) priorEl.innerHTML = "";
            return;
        }
        const steps = rows.map(r => Number(r.timestep));
        const distFirstCos = rows.map(r => Number(r.cosine_distance_to_first ?? r.distance_to_first_cosine ?? 0));
        const distPriorCos = rows.map(r => Number(r.cosine_distance_to_prior ?? r.distance_to_prior_cosine ?? 0));
        const custom = rows.map(r => [
            r.trajectory,
            Number(r.timestep),
            r.frame_path,
            r.first_frame_path,
            r.prior_frame_path,
            r.frame_label,
            r.action_label || "",
        ]);

        const layoutBase = {
            margin: { t: 32, r: 16, l: 50, b: 50 },
            template: "plotly_white",
            height: 240,
            title: { font: { size: 12 } },
            font: { size: 11 },
        };

        const layoutLineChart = {
            ...layoutBase,
            hovermode: "x unified",
            xaxis: {
                title: "timestep",
                showspikes: true,
                spikemode: "across",
                spikethickness: 1,
                spikedash: "dot",
                spikecolor: "#999",
            },
        };

        const actionMap = buildActionMap(rows);

        Plotly.newPlot(
            firstEl,
            [
                {
                    x: steps,
                    y: distFirstCos,
                    mode: "lines+markers",
                    name: "cosine distance to first",
                    marker: { size: 4, color: cosineFirstColor },
                    line: { width: 1.5, color: cosineFirstColor },
                    customdata: custom,
                    hovertemplate: "%{y:.4f}<extra></extra>",
                },
            ],
            {
                ...layoutLineChart,
                title: `${titlePrefix} Cosine distance to first latent`,
                yaxis: { title: `1 - cos(${axisLabel}0, ${axisLabel}t)` },
            },
            plotConfig,
        ).then(() => attachHover(firstEl, actionMap));

        Plotly.newPlot(
            priorEl,
            [
                {
                    x: steps,
                    y: distPriorCos,
                    mode: "lines+markers",
                    name: "cosine distance to prior",
                    marker: { size: 4, color: cosinePriorColor },
                    line: { width: 1.5, color: cosinePriorColor },
                    customdata: custom,
                    hovertemplate: "%{y:.4f}<extra></extra>",
                },
            ],
            {
                ...layoutLineChart,
                title: `${titlePrefix} Cosine distance to prior latent`,
                yaxis: { title: `1 - cos(${axisLabel}(t-1), ${axisLabel}t)` },
            },
            plotConfig,
        ).then(() => attachHover(priorEl, actionMap));
    };

    const buildL2Plots = (rows, firstEl, priorEl, label, axisLabel, titlePrefix) => {
        if (!rows.length) {
            if (firstEl) firstEl.innerHTML = `<p class='text-muted fst-italic'>No rows in ${label} CSV.</p>`;
            if (priorEl) priorEl.innerHTML = "";
            return;
        }
        const steps = rows.map(r => Number(r.timestep));
        const distFirst = rows.map(r => Number(r.distance_to_first ?? 0));
        const distPrior = rows.map(r => Number(r.distance_to_prior ?? 0));
        const custom = rows.map(r => [
            r.trajectory,
            Number(r.timestep),
            r.frame_path,
            r.first_frame_path,
            r.prior_frame_path,
            r.frame_label,
            r.action_label || "",
        ]);

        const layoutBase = {
            margin: { t: 32, r: 16, l: 50, b: 50 },
            template: "plotly_white",
            height: 240,
            title: { font: { size: 12 } },
            font: { size: 11 },
        };

        const layoutLineChart = {
            ...layoutBase,
            hovermode: "x unified",
            xaxis: {
                title: "timestep",
                showspikes: true,
                spikemode: "across",
                spikethickness: 1,
                spikedash: "dot",
                spikecolor: "#999",
            },
        };

        const actionMap = buildActionMap(rows);

        Plotly.newPlot(
            firstEl,
            [
                {
                    x: steps,
                    y: distFirst,
                    mode: "lines+markers",
                    name: "l2 distance to first",
                    marker: { size: 4, color: cosineFirstColor },
                    line: { width: 1.5, color: cosineFirstColor },
                    customdata: custom,
                    hovertemplate: "%{y:.4f}<extra></extra>",
                },
            ],
            {
                ...layoutLineChart,
                title: `${titlePrefix} L2 distance to first latent`,
                yaxis: { title: `||${axisLabel}0 - ${axisLabel}t||` },
            },
            plotConfig,
        ).then(() => attachHover(firstEl, actionMap));

        Plotly.newPlot(
            priorEl,
            [
                {
                    x: steps,
                    y: distPrior,
                    mode: "lines+markers",
                    name: "l2 distance to prior",
                    marker: { size: 4, color: cosinePriorColor },
                    line: { width: 1.5, color: cosinePriorColor },
                    customdata: custom,
                    hovertemplate: "%{y:.4f}<extra></extra>",
                },
            ],
            {
                ...layoutLineChart,
                title: `${titlePrefix} L2 distance to prior latent`,
                yaxis: { title: `||${axisLabel}(t-1) - ${axisLabel}t||` },
            },
            plotConfig,
        ).then(() => attachHover(priorEl, actionMap));
    };

    const updatePinState = (nextState) => {
        diagLossPinned = nextState;
        if (!diagLossWrapper || !diagLossPin) return;
        diagLossWrapper.classList.toggle("sticky-active", diagLossPinned);
        diagLossPin.classList.toggle("active", diagLossPinned);
        diagLossPin.setAttribute("aria-pressed", diagLossPinned ? "true" : "false");
        diagLossPin.setAttribute("title", diagLossPinned ? "Unpin training metrics plot" : "Pin training metrics plot");
    };

    if (diagLossPin) {
        diagLossPin.addEventListener("click", () => {
            updatePinState(!diagLossPinned);
        });
    }

    if (diagFigure && diagLossPlot) {
        Plotly.react(diagLossPlot, diagFigure.data, diagFigure.layout, buildPlotlyConfig(diagFigure.config || {})).then(() => {
            let lastHoverStep = null;
            diagLossPlot.on("plotly_hover", (event) => {
                const point = event?.points?.[0];
                if (!point || typeof point.x === "undefined") return;
                const step = Number(point.x);
                if (!Number.isFinite(step)) return;
                lastHoverStep = step;
                updateSelfDistanceImage(step, selfDistanceMapZ, selfDistanceStepsZ, stepImgZ, stepLabelZ, "Z");
                updateSelfDistanceImage(step, selfDistanceMapH, selfDistanceStepsH, stepImgH, stepLabelH, "H");
                updateSelfDistanceImage(step, selfDistanceMapP, selfDistanceStepsP, stepImgP, stepLabelP, "P");
            });
            diagLossPlot.on("plotly_unhover", () => {
                if (lastHoverStep === null) return;
                updateSelfDistanceImage(lastHoverStep, selfDistanceMapZ, selfDistanceStepsZ, stepImgZ, stepLabelZ, "Z");
                updateSelfDistanceImage(lastHoverStep, selfDistanceMapH, selfDistanceStepsH, stepImgH, stepLabelH, "H");
                updateSelfDistanceImage(lastHoverStep, selfDistanceMapP, selfDistanceStepsP, stepImgP, stepLabelP, "P");
            });
        });
    }

    const loadCsv = (url) => new Promise((resolve) => {
        if (!url) {
            resolve([]);
            return;
        }
        Papa.parse(url, {
            download: true,
            header: true,
            dynamicTyping: true,
            skipEmptyLines: true,
            complete: (results) => resolve(results.data || []),
            error: () => resolve([]),
        });
    });

    Promise.all([loadCsv(zCsvUrl), loadCsv(hCsvUrl), loadCsv(pCsvUrl)]).then(([zRows, hRows, pRows]) => {
        buildCosinePlots(zRows, zFirstPlotCos, zPriorPlotCos, "self_distance_z.csv", "z", "Z ·");
        buildCosinePlots(hRows, hFirstPlotCos, hPriorPlotCos, "self_distance_h.csv", "h", "H ·");
        buildCosinePlots(pRows, pFirstPlotCos, pPriorPlotCos, "self_distance_p.csv", "p", "P ·");
        buildL2Plots(zRows, zFirstPlotL2, zPriorPlotL2, "self_distance_z.csv", "z", "Z ·");
        buildL2Plots(hRows, hFirstPlotL2, hPriorPlotL2, "self_distance_h.csv", "h", "H ·");
        buildL2Plots(pRows, pFirstPlotL2, pPriorPlotL2, "self_distance_p.csv", "p", "P ·");
        const initialStep = zRows.length
            ? Number(zRows[zRows.length - 1].timestep)
            : (hRows.length
                ? Number(hRows[hRows.length - 1].timestep)
                : (pRows.length ? Number(pRows[pRows.length - 1].timestep) : 0));
        updateSelfDistanceImage(initialStep, selfDistanceMapZ, selfDistanceStepsZ, stepImgZ, stepLabelZ, "Z");
        updateSelfDistanceImage(initialStep, selfDistanceMapH, selfDistanceStepsH, stepImgH, stepLabelH, "H");
        updateSelfDistanceImage(initialStep, selfDistanceMapP, selfDistanceStepsP, stepImgP, stepLabelP, "P");
    });
    const tooltipTriggerList = Array.from(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.forEach((el) => {
        if (window.bootstrap) {
            new bootstrap.Tooltip(el);
        }
    });
});
</script>
{% endif %}
{% endblock %}
